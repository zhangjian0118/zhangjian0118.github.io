<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>kotlin面向对象 | Jian Zhang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、类和构造方法类与接口1. Kotlin中的类kotlin申明一个类： 12345class Bird &#123;    val weight: Double &#x3D; 500.0    val color: String &#x3D; &quot;blue&quot;    val age: Int &#x3D; 1fun fly() &#123;&#125; &#x2F;&#x2F; 全局可见&#125;  对应的Java版本： 12">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin面向对象">
<meta property="og:url" content="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Jian Zhang">
<meta property="og:description" content="一、类和构造方法类与接口1. Kotlin中的类kotlin申明一个类： 12345class Bird &#123;    val weight: Double &#x3D; 500.0    val color: String &#x3D; &quot;blue&quot;    val age: Int &#x3D; 1fun fly() &#123;&#125; &#x2F;&#x2F; 全局可见&#125;  对应的Java版本： 12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png">
<meta property="og:image" content="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png">
<meta property="og:image" content="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png">
<meta property="article:published_time" content="2026-01-25T10:28:45.000Z">
<meta property="article:modified_time" content="2026-01-25T10:42:19.005Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="kotlin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Jian Zhang" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jian Zhang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术 · 设计模式 · 思考</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-kotlin面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2026-01-25T10:28:45.000Z" itemprop="datePublished">2026-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      kotlin面向对象
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、类和构造方法"><a href="#一、类和构造方法" class="headerlink" title="一、类和构造方法"></a>一、类和构造方法</h1><h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="1-Kotlin中的类"><a href="#1-Kotlin中的类" class="headerlink" title="1. Kotlin中的类"></a>1. Kotlin中的类</h3><p>kotlin申明一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    val weight: Double = <span class="number">500.0</span></span><br><span class="line">    val color: String = <span class="string">&quot;blue&quot;</span></span><br><span class="line">    val age: Int = 1fun <span class="title function_">fly</span><span class="params">()</span> &#123;&#125; <span class="comment">// 全局可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的Java版本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> double weight = <span class="number">500.0D</span>;</span><br><span class="line">    <span class="meta">@NotNullprivate</span> </span><br><span class="line">    <span class="keyword">final</span> String color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int age = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> double getWeight() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNullpublic</span> </span><br><span class="line">    <span class="keyword">final</span> String getColor() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void fly() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin中类申明语法接近Java，但有很多不同之处</p>
<p>（1）不可变属性成员。 Kotlin支持用val在类中申明引用不可变的属性成员，这是利用Java中的final修饰符实现的</p>
<p>  (2) 属性默认值。因为Java的属性都有默认值，比如int类型默认值为0，引用类型默认值是null。所以在申明属性的时候我们不需要指定默认值。而在Kotlin中，除了显示第申明延迟初始化，不然就需要指定属性默认值。</p>
<p>（3）不同的可访问修饰符。Kotlin类的成员默认是全局可见，而Java的默认可见域是包作用域，因此在Java版本中必须采用public修饰才能达到相同的效果。</p>
<h3 id="2-可带有属性和默认方法的接口"><a href="#2-可带有属性和默认方法的接口" class="headerlink" title="2. 可带有属性和默认方法的接口"></a>2. 可带有属性和默认方法的接口</h3><p>Java8引入一个新特性，接口方法支持默认实现。但是Kotlin是基于Java6的。</p>
<p>（1）Kotlin中接口支持默认实现， 但是是基于DefaultImpls静态内部类实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">kind</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultImpls</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Flyer $<span class="built_in">this</span>)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="string">&quot;I can fly&quot;</span>;</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）接口中支持属性申明， 但是通过get方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line">    val height</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更简洁地构造对象"><a href="#更简洁地构造对象" class="headerlink" title="更简洁地构造对象"></a>更简洁地构造对象</h3><p>Java 中构造方法重载，通过new构造对象有两个缺点：</p>
<ul>
<li>如果需要支持任意参数组合来构造对象，那么需要实现构造方法非常多</li>
<li>每个构造方法中代码冗余。</li>
</ul>
<h3 id="3-构造方法默认参数"><a href="#3-构造方法默认参数" class="headerlink" title="3. 构造方法默认参数"></a>3. 构造方法默认参数</h3><p>在Kotlin中可以给构造方法地参数指定默认值，从而避免不必要地方法重载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Bird(val weight:Double = 0.00,val age:Int = 0, val color:String = &quot;blue&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里构造方法地参数名前加上val和var，等价于在Bird类内部声明了一个同名属性，我们可以用this来进行调用</p>
<p>前面的Bird类相当于</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(</span><br><span class="line">    weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, <span class="comment">// 参数名前没有val</span></span><br><span class="line">    age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    color: String = <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> weight: <span class="built_in">Double</span></span><br><span class="line">    <span class="keyword">val</span> age: Intval color: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight <span class="comment">// 构造方法参数可以在init语句块被调用this.age = age</span></span><br><span class="line">        <span class="keyword">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="4-init语句块"><a href="#4-init语句块" class="headerlink" title="4. init语句块"></a>4. init语句块</h3><p>Kotlin引入一种init语句块语法，属于构造函数的一部分，两者表现形式上是分离的。Bird类的构造函数在类外部，只能对参数进行赋值。如果我们想在初始化时做一些额外操作，就可以用init语句块来执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do some other things&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;the weight is <span class="subst">$&#123;weight&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当没有val或var的时候，构造方法的参数可以在init语句块被直接调用， 除此以外的其他地方都不可以调用。</p>
</blockquote>
<p>事实上我们构造方法还可以拥有多个init，他们会在对象被创建时按照类中从上到下的顺序先后执行。</p>
<p>再考虑一种场景，我们在创建一个类对象时，很可能不需要对所有属性进行传值。如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> sex: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">//鸟的性别通过羽毛颜色来区分</span></span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="keyword">if</span> (<span class="keyword">this</span>.color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟初始化：by-lazy-和-lateinit"><a href="#延迟初始化：by-lazy-和-lateinit" class="headerlink" title="延迟初始化：by lazy 和 lateinit"></a>延迟初始化：by lazy 和 lateinit</h2><p>在Kotlin中，不用在类对象初始化的时候就赋值，使用lateinit 和 by lazy两种语法来实现延迟初始化的效果。</p>
<p>By lazy:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> sex: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该变量必须是引用不可变的，而不能通过var来申明</li>
<li>在首次调用时，才会进行赋值操作，一旦赋值，后续它将不能被更改。</li>
</ul>
<p>lazy的背后是接受一个lambda并返回一个 Lazy 实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问该属性时只是返回记录的结果。</p>
<p>系统会对lazy属性默认加同步锁，同一时刻只允许一个线程对lazy进行初始化，所以时线程安全的。</p>
<p>Lateinit：</p>
<p>主要用于var声明的变量，然而它不能用于基本数据类型，如Int、Long等，我们需要用Integer这种包装类作为替代。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex: String <span class="comment">// sex 可以延迟初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printSex</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="keyword">if</span> (<span class="keyword">this</span>.color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            println(<span class="keyword">this</span>.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bird = Bird(<span class="number">1000.0</span>, <span class="number">2</span>, <span class="string">&quot;bule&quot;</span>)</span><br><span class="line">    bird.printSex()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主从构造方法"><a href="#主从构造方法" class="headerlink" title="主从构造方法"></a>主从构造方法</h2><p>假设当前我们知道鸟的生日，希望可以通过生日来得到鸟的年龄，然后创建一个Bird类对象。如何实现？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.DateTime</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(birth: DateTime) : <span class="keyword">this</span>(getAgeByBirth(birth)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过constructor方法定义了一个新的构造方法，它被称为从构造方法。每个类可最多存在一个主构造方法和多个从构造方法，如果主构造方法存在注解或可见修饰符，也必须像从构造方法一样加上constructor关键字，如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bird <span class="meta">@inject</span> <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个从构造方法由两个部分组成。一部分是对其他构造方法的委托，另一部分是由花括号包裹的代码块。执行顺序会先执行委托方法，然后执行自身代码逻辑。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.DateTime </span><br><span class="line"><span class="keyword">import</span> org.joda.time.Years</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(age: <span class="built_in">Int</span>) &#123; </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> </span><br><span class="line">    <span class="keyword">init</span> &#123; <span class="keyword">this</span>.age = age &#125; </span><br><span class="line">    <span class="keyword">constructor</span>(timestamp: <span class="built_in">Long</span>): <span class="keyword">this</span>(DateTime(timestamp)) <span class="comment">//构造函数A </span></span><br><span class="line">    <span class="keyword">constructor</span>(birth: DateTime): <span class="keyword">this</span>(getAgeByBirth(birth)) <span class="comment">//构造函数B </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAgeByBirth</span><span class="params">(birth: <span class="type">DateTime</span>)</span></span>: <span class="built_in">Int</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Years.yearsBetween(birth, DateTime.now()).years </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、访问修饰符"><a href="#二、访问修饰符" class="headerlink" title="二、访问修饰符"></a>二、访问修饰符</h1><h2 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h2><h3 id="1-类中默认的修饰符-final"><a href="#1-类中默认的修饰符-final" class="headerlink" title="1. 类中默认的修饰符 final"></a>1. 类中默认的修饰符 final</h3><p>kotlin中继承：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can fly.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="type">Bird</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can&#x27;t fly actually.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Kotlin中没有采用Java中的extend和implements关键字，而是使用“：”来替代类继承和接口实现</li>
<li>Kotlin中类和方法默认是不可以被继承和重写的，所以必须加上open修饰符</li>
</ul>
<h3 id="2-密封类限制类的继承"><a href="#2-密封类限制类的继承" class="headerlink" title="2. 密封类限制类的继承"></a>2. 密封类限制类的继承</h3><p>通过密封类限制类的继承：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = <span class="string">&quot;I can fly&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Eagle</span> : <span class="type">Bird</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I can fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bird</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $FF: synthetic method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Eagle</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Eagle</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>((DefaultConstructorMarker) <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin通过sealed关键字来修饰一个类为密封类，若要继承则需要将子类定义在同一个文件中，其他文件中的类无法继承这个类。</p>
<p>kotlin于Java的限制修饰符比较：</p>
<img src="/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" class="">

<h2 id="可见修饰符"><a href="#可见修饰符" class="headerlink" title="可见修饰符"></a>可见修饰符</h2><p>Kotlin中可见修饰符与Java比较：</p>
<p>（1）Kotlin与Java默认修饰符不同， Kotlin 是 public Java 是Default（包访问权限）</p>
<p>（2）Kotlin中有一个独特的修饰符internal(模块内访问， 一个模块可以看作一起编译的Kotlin文件组合)</p>
<p>（3）Kotlin可以在一个文件内单独申明方法和变量，同样支持可见修饰符</p>
<p>（4）Java中除了内部类可以用private修饰以外，其他类不允许private修饰，而kotlin可以（访问范围为当前kotlin文件）</p>
<p>（5）Kotlin 和java中protected的访问范围不同，Java中是包和子类可访问，而kotlin是只允许子类访问</p>
<img src="/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" class="">

<h1 id="三、解决多继承问题"><a href="#三、解决多继承问题" class="headerlink" title="三、解决多继承问题"></a>三、解决多继承问题</h1><h2 id="1-骡子的多继承困惑"><a href="#1-骡子的多继承困惑" class="headerlink" title="1. 骡子的多继承困惑"></a>1. 骡子的多继承困惑</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> void run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="title">extends</span> <span class="title">Animal</span> &#123; <span class="comment">//马</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;I am run very fast&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donkey</span> <span class="title">extends</span> <span class="title">Animal</span> &#123; <span class="comment">//驴</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;I am run very slow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span> <span class="title">extends</span> <span class="title">Horse</span>, <span class="type">Donkey</span> &#123; <span class="comment">//骡子</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>马和驴都继承了Animal类，并实现了Animal中的run抽象方法；</li>
<li>骡子是马和驴的杂交产物，它拥有两者的特性，于是Mule利用多继承同时继承了Horse和Donkey。</li>
</ul>
<p>目前看起来没有问题，然而当我们打算在Mule中实现run方法的时候，问题就产生了：Mule到底是继承Horse的run方法，还是Donkey的run方法呢？这个就是经典的钻石问题</p>
<img src="/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" class="">

<h2 id="2-接口实现多继承"><a href="#2-接口实现多继承" class="headerlink" title="2. 接口实现多继承"></a>2. 接口实现多继承</h2><p>利用接口来实现多继承：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">&quot;flying animals&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">&quot;flying animals&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">override</span> <span class="keyword">val</span> name: String) : Flyer, Animal &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can fly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Flyer&gt;.kind()<span class="comment">//可以指定继承哪个父接口的方法， 这里也可以自己实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bird = Bird(<span class="string">&quot;sparrow&quot;</span>)</span><br><span class="line">    println(bird.kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Kotlin中实现一个接口时，需要实现接口中没有默认实现的方法及未初始化的属性，若同时实现多个接口，而接口间又有相同方法名的默认实现时，则需要<strong>主动指定使用哪个接口的方法或者重写方法</strong>；</li>
<li>如果是默认的接口方法，你可以在实现类中通过“super”这种方式调用它，其中T为拥有该方法的接口名；</li>
<li>在实现接口的属性和方法时，都必须带上override关键字，不能省略。</li>
</ul>
<h2 id="3-内部类解决多继承问题"><a href="#3-内部类解决多继承问题" class="headerlink" title="3. 内部类解决多继承问题"></a>3. 内部类解决多继承问题</h2><p>java中的内部类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterJava</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;This is Java&#x27;s inner class syntax.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerJava</span> &#123;  <span class="comment">//内部类public void printName()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin中的内部类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterKotlin</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;This is truely Kotlin&#x27;s inner class syntax.&quot;</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">InnerKotlin</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</span><br><span class="line">            print(<span class="string">&quot;the name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>内部类vs嵌套类</strong></p>
<p>众所周知，在Java中，我们通过在内部类的语法上增加一个static关键词，把它变成一个嵌套类。然而，Kotlin则是相反的思路，默认是一个嵌套类，必须加上inner关键字才是一个内部类，也就是说可以把静态的内部类看成嵌套类。</p>
<p>内部类和嵌套类有明显的差别，具体体现在：内部类包含着对其外部类实例的引用，在内部类中我们可以使用外部类中的属性，比如上面例子中的name属性；而嵌套类不包含对其外部类实例的引用，所以它无法调用其外部类的属性。</p>
</blockquote>
<p>用内部类改下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123; <span class="comment">//马</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can run fast&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Donkey</span> &#123; <span class="comment">//驴</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doLongTimeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can do some thing long time&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span> &#123; <span class="comment">//骡子</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> &#123;</span><br><span class="line">        HorseC().runFast()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doLongTimeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">        DonkeyC().doLongTimeThing()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个内部类， 一个继承Horse 一个继承 Donkey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">HorseC</span> : <span class="type">Horse</span>() </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DonkeyC</span> : <span class="type">Donkey</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以在一个类内部定义多个内部类，<strong>每个内部类的实例都有自己的独立状态</strong>，它们与外部对象的信息相互独立；</li>
<li>通过让内部类HorseC、DonkeyC分别继承Horse和Donkey这两个外部类，我们就可以在Mule类中定义它们的实例对象，从而获得了Horse和Donkey两者不同的状态和行为；</li>
<li>我们可以利用private修饰内部类，使得其他类都不能访问内部类，具有非常良好的封装性。</li>
</ul>
<h2 id="4-使用委托代替多继承"><a href="#4-使用委托代替多继承" class="headerlink" title="4. 使用委托代替多继承"></a>4. 使用委托代替多继承</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CanFly</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CanEat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Flyer</span> : <span class="type">CanFly</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can fly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> : <span class="type">CanEat</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CanFly 相关方法委托给flyer， CanEat相关方法委托给animal </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(flyer: Flyer, animal: Animal) : CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> flyer = Flyer()</span><br><span class="line">    <span class="keyword">val</span> animal = Animal()</span><br><span class="line">    <span class="keyword">val</span> b = Bird(flyer, animal)</span><br><span class="line">    b.fly()</span><br><span class="line">    b.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、数据类"><a href="#四、数据类" class="headerlink" title="四、数据类"></a>四、数据类</h1><h2 id="1-用data-class-创建数据类"><a href="#1-用data-class-创建数据类" class="headerlink" title="1. 用data class 创建数据类"></a>1. 用data class 创建数据类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></table></figure>

<p>翻译成java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> &#123;</span><br><span class="line">        Intrinsics.checkParameterIsNotNull(var1, <span class="string">&quot;&lt;set-?&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.color = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(<span class="type">double</span> weight, <span class="type">int</span> age, <span class="meta">@NotNull</span> String color)</span> &#123;</span><br><span class="line">        Intrinsics.checkParameterIsNotNull(color, <span class="string">&quot;color&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">component1</span><span class="params">()</span> &#123; <span class="comment">//Java中没有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">component2</span><span class="params">()</span> &#123; <span class="comment">//Java中没有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">component3</span><span class="params">()</span> &#123; <span class="comment">//Java中没有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title function_">copy</span><span class="params">(<span class="type">double</span> weight, <span class="type">int</span> age, <span class="meta">@NotNull</span> String color)</span> &#123; <span class="comment">//Java中没有</span></span><br><span class="line">        Intrinsics.checkParameterIsNotNull(color, <span class="string">&quot;color&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(weight, age, color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $FF: synthetic method// $FF: bridge method</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="type">double</span> var1, <span class="type">int</span> var3, String var4, <span class="type">int</span> var5, Object var6) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var1 = var0.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var3 = var0.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var4 = var0.color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一行代码为我们实现了 getter&#x2F;setter、equals、hashcode、构造函数等方法， 另外还实现了copy和componentN与解构</p>
<h2 id="2-copy和componentN"><a href="#2-copy和componentN" class="headerlink" title="2. copy和componentN"></a>2. copy和componentN</h2><p>copy方法的主要作用就是帮我们从已有的数据类对象中拷贝一个新的数据类对象。当然你可以传入相应参数来生成不同的对象。但同时我们发现，在copy的执行过程中，若你未指定具体属性的值，那么新生成的对象的属性值将使用被copy对象的属性值，这便是我们平常所说的浅拷贝。</p>
<p>实际上copy更像是一种语法糖，假如我们的类是不可变的，属性不可以修改，那么我们只能通过copy来帮我们基于原有对象生成一个新的对象。比如下面的两个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明的Bird属性可变</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1</span><br><span class="line">b2.age = <span class="number">2</span></span><br><span class="line"><span class="comment">//声明的Bird属性不可变</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1.copy(age = <span class="number">2</span>) <span class="comment">//只能通过copy</span></span><br></pre></td></tr></table></figure>

<p>copy更像提供了一种简洁的方式帮我们复制一个对象，但它是一种浅拷贝的方式。所以在使用copy的时候要注意使用场景，因为数据类的属性可以被修饰为var，这便不能保证不会出现引用修改问题。</p>
<p>接下来我们来看看componentN方法。简单来说，componentN可以理解为类属性的值，其中N代表属性的顺序，比如component1代表第1个属性的值，component3代表第3个属性的值。那么，这样设计到底有什么用呢？我们来思考一个问题，我们或多或少地知道怎么将属性绑定到类上，但是对如何将类的属性绑定到相应变量上却不是很熟悉。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="comment">//通常方式</span></span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br><span class="line"><span class="comment">//kotlin进阶</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></table></figure>

<p>看到Kotlin的语法相信你一定会感到兴奋，因为你可能写过类似下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String birdInfo = <span class="string">&quot;20.0,1,bule&quot;</span>;</span><br><span class="line">String[] temps = birdInfo.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">double weight = <span class="built_in">Double</span>.valueOf(temps[<span class="number">0</span>]);</span><br><span class="line">int age = Integer.valueOf(temps[<span class="number">1</span>]);</span><br><span class="line">String color = temps[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>这样代码有时真的很烦琐，我们明明知道值的情况，却要分好几步来给变量赋值。很幸运，Kotlin提供了更优雅的做法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个语法很简洁也很直观。那么这到底是一种什么魔法呢？其实原理也很简单，就是解构，通过编译器的约定实现解构。</p>
<p>Kotlin也提供了其他常用的数据类，让使用者不必主动声明这些数据类，它们分别是Pair和Triple。其中Pair是二元组，可以理解为这个数据类中有两个属性；Triple是三元组，对应的则是3个属性。我们先来看一下它们的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pair</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Pair</span>(</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> second: B)</span><br><span class="line"><span class="comment">//Triple</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Triple</span>(</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> second: B,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> third: C)</span><br></pre></td></tr></table></figure>

<p>可以发现Pair和Triple都是数据类，它们的属性可以是任意类型，我们可以按照属性的顺序来获取对应属性的值。因此，我们可以这么使用它们：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">20.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> triple = Triple(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="comment">//利用属性顺序获取值</span></span><br><span class="line"><span class="keyword">val</span> weightP = pair.first</span><br><span class="line"><span class="keyword">val</span> ageP = pair.second</span><br><span class="line"><span class="keyword">val</span> weightT = triple.first</span><br><span class="line"><span class="keyword">val</span> ageT = triple.second</span><br><span class="line"><span class="keyword">val</span> colorT = triple.third</span><br><span class="line"><span class="comment">//当然我们也可以利用解构</span></span><br><span class="line"><span class="keyword">val</span> (weightP, ageP) = Pair(<span class="number">20.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> (weightT, ageT, colorT) = Triple(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>数据类中的解构基于componentN函数，如果自己不声明componentN函数，那么就会默认根据主构造函数参数来生成具体个数的componentN函数，与从构造函数中的参数无关。</p>
<h2 id="3-数据类的约定和使用"><a href="#3-数据类的约定和使用" class="headerlink" title="3. 数据类的约定和使用"></a>3. 数据类的约定和使用</h2><ul>
<li>数据类必须拥有一个构造方法，该方法<strong>至少包含一个参数</strong>，一个没有数据的数据类是没有任何用处的；</li>
<li>与普通的类不同，数据类构造方法的参数<strong>强制使用var或者val进行声明</strong>；</li>
<li>data class之前不能用abstract、open、sealed或者inner进行修饰；</li>
<li>在Kotlin1.1版本前数据类只允许实现接口，之后的版本既可以实现接口也可以继承类。</li>
</ul>
<h1 id="五、从static到object"><a href="#五、从static到object" class="headerlink" title="五、从static到object"></a>五、从static到object</h1><h2 id="1-什么是伴生对象"><a href="#1-什么是伴生对象" class="headerlink" title="1. 什么是伴生对象"></a>1. 什么是伴生对象</h2><p>java中static关键字使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prize</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prize</span><span class="params">(String name, <span class="type">int</span> count, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">TYPE_REDPACK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">TYPE_COUPON</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRedpack</span><span class="params">(Prize prize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prize.type == TYPE_REDPACK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prize</span> <span class="variable">prize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Prize</span>(<span class="string">&quot;红包&quot;</span>, <span class="number">10</span>, Prize.TYPE_REDPACK);</span><br><span class="line">        System.out.println(Prize.isRedpack(prize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个类中既有静态变量、静态方法，也有普通变量、普通方法的声明。然而，静态变量和静态方法是属于一个类的，普通变量、普通方法是属于一个具体对象的。虽然有static作为区分，然而在代码结构上职能并不是区分得很清晰。</p>
<p><strong>伴生对象</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prize</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> count: <span class="built_in">Int</span>, <span class="keyword">val</span> type: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> TYPE_REDPACK = 0val TYPE_COUPON = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">isRedpack</span><span class="params">(prize: <span class="type">Prize</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> prize.type == TYPE_REDPACK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> prize = Prize(<span class="string">&quot;红包&quot;</span>, <span class="number">10</span>, Prize.TYPE_REDPACK)</span><br><span class="line">    print(Prize.isRedpack(prize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该版本在语义上更清晰了。而且，companion object用花括号包裹了所有静态属性和方法，使得它可以与Prize类的普通方法和属性清晰地区分开来。最后，我们可以使用点号来对一个类的静态的成员进行调用。</p>
<p>伴生对象的另一个作用是可以实现工厂方法模式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prize</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> count: <span class="built_in">Int</span>, <span class="keyword">val</span> type: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> TYPE_COMMON = 1val TYPE_REDPACK = 2val TYPE_COUPON = 3val defaultCommonPrize = Prize(<span class="string">&quot;普通奖品&quot;</span>, <span class="number">10</span>, Prize.TYPE_COMMON)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newRedpackPrize</span><span class="params">(name: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> = Prize(name, count, Prize.TYPE_REDPACK)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newCouponPrize</span><span class="params">(name: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> = Prize(name, count, Prize.TYPE_COUPON)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">defaultCommonPrize</span><span class="params">()</span></span> = defaultCommonPrize  <span class="comment">//无须构造新对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> redpackPrize = Prize.newRedpackPrize(<span class="string">&quot;红包&quot;</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> couponPrize = Prize.newCouponPrize(<span class="string">&quot;十元代金券&quot;</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> commonPrize = Prize.defaultCommonPrize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-天生的单例：object"><a href="#2-天生的单例：object" class="headerlink" title="2. 天生的单例：object"></a>2. 天生的单例：object</h2><p>在Kotlin中，由于object的存在，我们可以直接用它来实现单例，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig &#123;</span><br><span class="line">    <span class="keyword">var</span> host: String = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="keyword">var</span> port: <span class="built_in">Int</span> = <span class="number">3306</span></span><br><span class="line">    <span class="keyword">var</span> username: String = <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="keyword">var</span> password: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于object全局声明的对象只有一个，所以它并不用语法上的初始化，甚至都不需要构造方法。因此，我们可以说，object创造的是天生的单例，我们并不需要在Kotlin中去构建一个类似Java的单例模式。由于DatabaseConfig的属性是用var声明的String，我们还可以修改它们：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConfig.host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">DatabaseConfig.poet = <span class="number">3307</span></span><br></pre></td></tr></table></figure>

<h2 id="3-object表达式"><a href="#3-object表达式" class="headerlink" title="3. object表达式"></a>3. object表达式</h2><p>java版本对字符串排序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="string">&quot;redpack&quot;</span>, <span class="string">&quot;score&quot;</span>, <span class="string">&quot;card&quot;</span>);</span><br><span class="line">Collections.sort(list, new Comparator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> int compare(String s1, String s2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>kotlin版本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> comparator = <span class="keyword">object</span> : Comparator &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(s1: <span class="type">String</span>?, s2: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -1else <span class="keyword">if</span> (s2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> 1return s1.compareTo(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, comparator)</span><br></pre></td></tr></table></figure>

<p>lambda表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> comparator = Comparator &#123; s1, s2 -&gt;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Comparator</span> -<span class="number">1</span>  <span class="comment">//我们已经在第2章中接触过这种语法了else if (s2 == null)</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Comparator</span> <span class="number">1</span></span><br><span class="line">    s1.compareTo(s2)</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, comparator)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象表达式与Lambda表达式哪个更适合代替匿名内部类？</p>
<p>当你的匿名内部类使用的类接口只需要实现一个方法时，使用Lambda表达式更适合；当匿名内部类内有多个方法实现的时候，使用object表达式更加合适。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="cuidFQDpXOmY1lnkXWto2HG7Q" data-title="kotlin面向对象" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlin/" rel="tag">kotlin</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2026/01/25/%E8%AE%BF%E9%97%AE%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">访问器设计模式</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/" rel="tag">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/25/kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">kotlin面向对象</a>
          </li>
        
          <li>
            <a href="/2026/01/25/%E8%AE%BF%E9%97%AE%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">访问器设计模式</a>
          </li>
        
          <li>
            <a href="/2026/01/25/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">迭代器设计模式</a>
          </li>
        
          <li>
            <a href="/2026/01/24/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">模板方法设计模式</a>
          </li>
        
          <li>
            <a href="/2026/01/24/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">抽象工厂设计模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>